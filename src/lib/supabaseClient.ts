import { createBrowserClient } from '@supabase/ssr';
import type { PostgrestError } from '@supabase/supabase-js';

// Define the type for a single requirement based on your schema
export interface Requirement {
  id?: string; // id is generated by Supabase
  user_id: string;
  project_name: string;
  date?: string; // date is defaulted by Supabase
  problem_statement?: string;
  role?: string;
  output_type?: string[];
  outcome?: string[];
  device_type?: string[];
  project_type?: 'new' | 'old';
  created_at?: string;
}

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Supabase URL and anonymous key are required.');
}

export const supabase = createBrowserClient(supabaseUrl, supabaseAnonKey);

/**
 * Inserts a new requirement into the Supabase 'requirements' table.
 * @param requirement - The requirement object to insert.
 * @returns A promise that resolves with the inserted data or an error.
 */
export async function insertRequirement(
  requirement: Requirement
): Promise<{ data: Requirement[] | null; error: PostgrestError | null }> {
  const { data, error } = await supabase
    .from('requirements')
    .insert([requirement])
    .select();

  return { data, error };
}

/**
 * Fetches all requirements for a given user ID.
 * @param userId - The UUID of the user.
 * @returns A promise that resolves with an array of requirements or an error.
 */
export async function fetchRequirementsByUserId(
  userId: string
): Promise<{ data: Requirement[] | null; error: PostgrestError | null }> {
  const { data, error } = await supabase
    .from('requirements')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false });

  return { data, error };
}
